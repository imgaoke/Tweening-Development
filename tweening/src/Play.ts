import * as Phaser from "Phaser";
import Tween from "./Tween";
import Tweens from "./Tweens";


export default class Play extends Phaser.Scene {

    tw : Tweens;

    spriteX: Phaser.GameObjects.Sprite;

    count;

    constructor() {
        super("Play");
    }

    create() {
        console.log("Play.create()");

        this.tw = new Tweens(this.game);

        this.spriteX = this.add.sprite(160, 120, "playership1").setOrigin(0.5, 0.5).setAlpha(1);

        // Enables movement of player with WASD keys
        this.input.keyboard.on('keydown-ONE', function (event: object) {
            this.scene.button1();
        });
        this.input.keyboard.on('keydown-TWO', function (event: object) {
            this.scene.button2();
        });
        this.input.keyboard.on('keydown-THREE', function (event: object) {
            this.scene.button3();
        });
        this.input.keyboard.on('keydown-FOUR', function (event: object) {
            this.scene.button4();
        }); 
        this.input.keyboard.on('keydown-R', function (event: object) {
            this.scene.restart();
        });
    }

    update(time: number, delta: number) {    
        this.tw.update(time, delta);   
    }    

    button1() {
        // TODO: some showcase on this.spriteX using SmoothStepN on Alpha
        this.spriteX.alpha = 0;
        // smooth step 5 is taken as an example here
        let smoothStep5 = function(t: number){
            return Tween.smoothStepN(t, 5);
        }
        this.tw.tween(this.spriteX, "alpha", 1, true, false, 3, smoothStep5, null, null, null, null, null);
    }

    

    button2() {
        // TODO: some showcase on this.spriteX using funky bezier on Alpha, Rotation and Position
        //Alpha
        this.spriteX.alpha = 0;
        this.tw.tween(this.spriteX, "alpha", 1, true, false, 3, Tween.linearBezier, null, null, null, null, null);
        //Rotation
        this.spriteX.angle = -90;
        this.tw.tween(this.spriteX, "angle", 90, true, false, 5, Tween.easeInQuadraticBezier, null, null, null, null, null);
        //Position
        this.tw.tween(this.spriteX, "x", 600, true, false, 10, Tween.easeOutQuadraticBezier, null, null, null, null, null);
        this.tw.tween(this.spriteX, "y", 200, true, false, 10, Tween.easeOutQuadraticBezier, null, null, null, null, null);
    }
    
    // random generate spline points starting from the second point
    generalSplineEndFunction (tween: Tween): void{
        if (tween.target == "x"){
            this.tw.tween(tween.target, tween.property, Math.random() * 600, tween.isEase, tween.isSmoothSpline, 3, tween.func, tween.on_end, null, null, null, null); 
        }
        else{
            this.tw.tween(tween.target, tween.property, Math.random() * 440, tween.isEase, tween.isSmoothSpline, 3, tween.func, tween.on_end, null, null, null, null); 
        }
    }

    genericCallback(func){
        let THIS: Play = this;
        function callback(tween: Tween): void {
            func.call(THIS, tween);
        }
        return callback;
    }

    button3() {
        
        // TODO: some showcase on this.spriteX using spline on Beziers utilizing on_end

        // first point on the spline is (600, 40) and the rest points on the spline is randomly generated between (0,0) and (600, 440)
        // curves in the spline is generated by quadratic Bezier curves
        this.tw.tween(this.spriteX, "x", 600, false, false, 3, null, this.genericCallback(this.generalSplineEndFunction), null, null, null, null);
        this.tw.tween(this.spriteX, "y", 40, false, false, 3, null, this.genericCallback(this.generalSplineEndFunction), null, null, null, null);
    }

    
    // smooth spline is done by Catmull-Rom splines method which uses transfer from cubit Hermite curves to cubic Bezier curves
    firstX;
    secondX;
    thirdX;
    firstY;
    secondY;
    thirdY;
    // initial speed
    uSpeed = 0;
    endFunctionForSmoothSpline (tween: Tween, list: Array<number>): void{
        if (tween.property == "x"){
            console.log("here1");
            if (this.firstX == undefined){
                this.firstX = list.shift();
                this.secondX = list.shift();
                this.thirdX = list.shift();
            }
            else{
                this.firstX = this.secondX;
                this.secondX = this.thirdX;
                this.thirdX = list.shift();
            }
            // the tween is executed until the first and second point is the last two points on the spline
            if (this.firstX != undefined && this.secondX != undefined){
                this.tw.tween(tween.target, tween.property, this.secondX, false, true, 3, tween.func, tween.on_end, this.uSpeed, this.firstX, this.secondX, this.thirdX);
            }
            if(this.thirdX != undefined){
                this.uSpeed = (this.thirdX - this.firstX) / 2;
            }
            
        }
        else{
            if (this.firstY == undefined){
                this.firstY = list.shift();
                this.secondY = list.shift();
                this.thirdY = list.shift();
            }
            else{
                this.firstY = this.secondY;
                this.secondY = this.thirdY;
                this.thirdY = list.shift();
            }
            // the tween is executed until the first and second point is the last two points on the spline
            if (this.firstY != undefined && this.secondY != undefined){
                console.log("first:" + this.firstY);
                console.log("second:" + this.secondY);
                console.log("third:" + this.thirdY);
                this.tw.tween(tween.target, tween.property, this.secondY, false, true, 3, tween.func, tween.on_end, this.uSpeed, this.firstY, this.secondY, this.thirdY);
            }
            if(this.thirdY != undefined){
                this.uSpeed = (this.thirdX - this.firstX) / 2;
            }
            
        }
    }

    genericCallbackWithVarargs(func, ...list){
        let THIS: Play = this;
        function callback(tween: Tween): void {
            func.call(THIS, tween, list);
        }
        return callback;
    }

    button4() {    
        // TODO: some showcase some smooth spline movement, change position of this.sprite3
        //       the spline must be built using single line of code, either using varargs
        //       or the Builder pattern

        // the first target position is (0,0) but the time to get there is set to 0 so the first target position is dummy
        // the spline coordiantes will be passed as varargs after the first argument to the function genericCallbackWithVarargs in which the first coordinates is the sprite's current position
        this.tw.tween(this.spriteX, "x", 0, false, false, 0, null, this.genericCallbackWithVarargs(this.endFunctionForSmoothSpline, 160, 400, 500, 40), null, null, null, null);
        this.tw.tween(this.spriteX, "y", 0, false, false, 0, null, this.genericCallbackWithVarargs(this.endFunctionForSmoothSpline, 120, 100, 300, 40), null, null, null, null);
    }

    restart() {
        this.scene.restart();
    }

}